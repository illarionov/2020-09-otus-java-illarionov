package ru.otus.jdbc.mapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.otus.core.annnotations.Id;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static java.util.function.Predicate.not;

class EntityClassMetaDataParser<T> {

    private static final Logger logger = LoggerFactory.getLogger(EntityClassMetaDataParser.class);

    private final Class<T> clazz;

    List<Field> allFields;

    EntityClassMetaDataParser(Class<T> clazz) {
        this.clazz = clazz;
    }

    public EntityClassMetaData<T> parse() throws ClassParseException {
        initAllFields();

        for (Field f : allFields) {
            f.setAccessible(true);
        }

        return new EntityClassMetaDataImpl<>(
                getName(),
                getConstructor(),
                getIdField(),
                isIdFieldAutoGenerated(),
                allFields,
                getFieldsWithoutId()
        );
    }

    private void initAllFields() {
        allFields = Stream.of(clazz.getDeclaredFields())
                .filter(f -> !f.isSynthetic()
                        && !Modifier.isTransient(f.getModifiers())
                        && !Modifier.isStatic(f.getModifiers()))
                .collect(Collectors.toUnmodifiableList());
    }

    private String getName() {
        return clazz.getSimpleName().toLowerCase(Locale.ROOT);
    }

    private Constructor<T> getConstructor() {
        Constructor<T> constructor = findAllArgsConstructor();
        if (constructor != null) {
            return constructor;
        }

        logger.trace("All args constructor not found");

        constructor = findNoArgsConstructor();
        if (constructor != null) {
            return constructor;
        }
        
        throw new ClassParseException("No suitable constructor found");
    }

    private Constructor<T> findNoArgsConstructor() {
        for (Constructor<?> constructor : clazz.getConstructors()) {
            if (constructor.getParameterCount() == 0) {
                return (Constructor<T>) constructor;
            }
        }
        return null;
    }

    private Constructor<T> findAllArgsConstructor() {
        for (Constructor<?> constructor : clazz.getConstructors()) {
            if (isAllArgsConstructor(constructor)) {
                //noinspection unchecked
                return (Constructor<T>) constructor;
            }
        }
        return null;
    }

    private boolean isAllArgsConstructor(Constructor<?> constructor) {
        Map<String, Class<?>> parameters = Stream.of(constructor.getParameters())
                .collect(Collectors.toMap(Parameter::getName, Parameter::getType));

        for (Field f : allFields) {
            Class<?> parameterType = parameters.remove(f.getName());
            if (parameterType == null) {
                return false;
            }
            if (!parameterType.equals(f.getType())) {
                return false;
            }
        }

        return parameters.isEmpty();
    }

    private Field getIdField() {
        return allFields.stream()
                .filter(f -> f.isAnnotationPresent(Id.class))
                .findFirst()
                .orElseThrow(() -> new ClassParseException("No fields marked with annotation Id has been found"));
    }

    private boolean isIdFieldAutoGenerated() {
        return getIdField().getAnnotation(Id.class).autoGenerated();
    }

    private List<Field> getFieldsWithoutId() {
        Field idField = getIdField();
        return allFields.stream()
                .filter(not(idField::equals))
                .collect(Collectors.toUnmodifiableList());
    }


    public static class ClassParseException extends JdbcMapperException {

        public ClassParseException(String message) {
            super(message);
        }

    }
}
