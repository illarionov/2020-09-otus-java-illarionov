package ru.otus.jdbc.mapper;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.otus.jdbc.DbExecutor;
import ru.otus.jdbc.sessionmanager.SessionManagerJdbc;

import java.lang.reflect.*;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class JdbcMapperImpl<T, K> implements JdbcMapper<T, K> {

    private static final Logger logger = LoggerFactory.getLogger(JdbcMapperImpl.class);

    private final EntityClassMetaData<T> classMetaData;

    private final EntitySQLMetaData sqlMetaData;

    private final SessionManagerJdbc sessionManager;

    private final DbExecutor dbExecutor;

    private final ResultSetToObjectMapper<T> findByIdResultSetMapper;

    public static <T, K> JdbcMapperImpl<T, K> create(Class<T> clazz, SessionManagerJdbc sessionManager, DbExecutor dbExecutor) throws JdbcMapperException {
        EntityClassMetaData<T> classMetaData = new EntityClassMetaDataParser<>(clazz).parse();
        EntitySQLMetaData sqlMetaData = new JdbcEntitySQLMetaDataBuilder(sessionManager, classMetaData).build();
        return new JdbcMapperImpl<>(classMetaData, sqlMetaData, sessionManager, dbExecutor);
    }

    private JdbcMapperImpl(EntityClassMetaData<T> classMetaData, EntitySQLMetaData sqlMetaData, SessionManagerJdbc sessionManager, DbExecutor dbExecutor) {
        this.classMetaData = classMetaData;
        this.sqlMetaData = sqlMetaData;
        this.findByIdResultSetMapper = createResultSetMapper(classMetaData);
        this.sessionManager = sessionManager;
        this.dbExecutor = dbExecutor;
    }

    @Override
    public K insert(T objectData) {
        Objects.requireNonNull(objectData);

        String sql = sqlMetaData.getInsertSql();
        
        Stream<Field> bindFields;
        if (classMetaData.isIdFieldAutoGenerated()) {
            bindFields = classMetaData.getFieldsWithoutId().stream();
        } else {
            bindFields = classMetaData.getAllFields().stream();
        }
        List<Object> params = bindFields
                .map(field -> {
                    try {
                        return field.get(objectData);
                    } catch (IllegalAccessException e) {
                        throw new JdbcMapperException(e);
                    }
                })
                .collect(Collectors.toUnmodifiableList());
        
        K resultId;
        try {
            resultId = dbExecutor.executeInsert(getConnection(), sql, params);
            
            if (classMetaData.isIdFieldAutoGenerated() && !Modifier.isFinal(classMetaData.getIdField().getModifiers())) {
                classMetaData.getIdField().set(objectData, resultId);
            }
        } catch (SQLException | IllegalAccessException exception) {
            throw new JdbcMapperException(exception);
        }
        return resultId;
    }

    @Override
    public K update(T objectData) {
        Objects.requireNonNull(objectData);

        String sql = sqlMetaData.getUpdateSql();
        List<Object> params = Stream.concat(classMetaData.getAllFields().stream(),
                Stream.of(classMetaData.getIdField()))
                .map(field -> {
                    try {
                        return field.get(objectData);
                    } catch (IllegalAccessException e) {
                        throw new JdbcMapperException(e);
                    }
                })
                .collect(Collectors.toUnmodifiableList());
        
        try {
            return dbExecutor.executeInsert(getConnection(), sql, params);
        } catch (SQLException exception) {
            throw new JdbcMapperException(exception);
        }
    }

    @Override
    public Optional<T> findById(K id) {
        String sql = sqlMetaData.getSelectByIdSql();
        List<Object> params = Collections.singletonList(id);

        try {
            return dbExecutor.executeSelect(getConnection(), sql, params, resultSet -> {
                try {
                    if (resultSet.next()) {
                        return Optional.of(findByIdResultSetMapper.apply(resultSet));
                    } else {
                        return Optional.empty();
                    }
                } catch (SQLException exception) {
                    throw new JdbcMapperException(exception);
                }
            });
        } catch (JdbcMapperException exception) {
            throw exception;
        } catch (Exception e) {
            throw new JdbcMapperException(e);
        }
    }

    @Override
    public List<T> findAll() {
        String sql = sqlMetaData.getSelectAllSql();
        try {
            return dbExecutor.executeSelect(getConnection(), sql, Collections.emptyList(), resultSet -> {
                List<T> result = new ArrayList<>();
                try {
                    while (resultSet.next()) {
                        result.add(findByIdResultSetMapper.apply(resultSet));
                    }
                } catch (SQLException sqlException) {
                    throw new JdbcMapperException(sqlException);
                }
                return result;
            });
        } catch (JdbcMapperException mapperException) {
            throw mapperException;
        } catch (Exception exception) {
            throw new JdbcMapperException(exception);
        }
    }

    private Connection getConnection() {
        return sessionManager.getCurrentSession().getConnection();
    }


    private static <T> ResultSetToObjectMapper<T> createResultSetMapper(EntityClassMetaData<T> classMetaData) {
        if (classMetaData.getConstructor().getParameterCount() > 0) {
            return new AllArgsConstructorObjectMapper<>(classMetaData.getAllFields(), classMetaData.getConstructor());
        } else {
            return new NoArgsConstructorObjectMapper<>(classMetaData.getAllFields(), classMetaData.getConstructor());
        }
    }

    private interface ResultSetToObjectMapper<R> {
        R apply(ResultSet resultSet) throws SQLException, JdbcMapperException;
    }

    private static class AllArgsConstructorObjectMapper<R> implements ResultSetToObjectMapper<R> {

        private final List<Field> fields;

        private final Constructor<R> constructor;

        private final Map<String, Integer> constructorArgs;

        /**
         * @param fields поля в порядке, совпадающим с полями в ResultSet
         * @param constructor all args конструктор
         */
        private AllArgsConstructorObjectMapper(List<Field> fields, Constructor<R> constructor) {
            this.fields = fields;
            this.constructor = constructor;

            Parameter[] parameters = constructor.getParameters();
            constructorArgs = new HashMap<>(parameters.length);
            for (int i = 0; i < parameters.length; i++) {
                constructorArgs.put(parameters[i].getName(), i);
            }
        }

        public R apply(ResultSet resultSet) throws SQLException, JdbcMapperException {
            Object[] initArgs = new Object[this.constructorArgs.size()];

            int idx = 1;
            for (Field field : fields) {
                initArgs[this.constructorArgs.get(field.getName())] = resultSet.getObject(idx);
                idx += 1;
            }

            try {
                return constructor.newInstance(initArgs);
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
                throw new JdbcMapperException("Can not create object", e);
            }

        }
    }

    private static class NoArgsConstructorObjectMapper<R> implements ResultSetToObjectMapper<R> {

        private final List<Field> fields;

        private final Constructor<R> constructor;

        /**
         * @param fields поля, в порядке, совпадающим с полями в ResultSet
         * @param constructor конструктор без аргументов
         */
        private NoArgsConstructorObjectMapper(List<Field> fields, Constructor<R> constructor) {
            this.fields = fields;
            this.constructor = constructor;
        }

        @Override
        public R apply(ResultSet resultSet) throws SQLException, JdbcMapperException {
            R result;
            try {
                result = constructor.newInstance();

                int idx = 1;
                for (Field field : fields) {
                    Object value = resultSet.getObject(idx);
                    idx += 1;

                    field.set(result, value);
                }
            } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {
                throw new JdbcMapperException("Can not create object", e);
            }

            return result;
        }
    }
}
